# -*- coding: utf-8 -*-
"""Straighten.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1BF8vx524eO2hUvSrduCZoMKrepx9A23J

***Text Straightening and Testing ***
"""

from PIL import Image
import numpy as np

def preprocess_image(image_path, target_size=(224, 224)):
    # Open image using PIL
    img = Image.open(image_path)

    # Resize image
    img = img.resize(target_size)

    # Convert image to numpy array
    img_array = np.array(img)

    # Normalize pixel values (if needed)
    img_array = img_array / 255.0  # Example: Normalize pixel values to [0, 1]

    # Add any other preprocessing steps as needed

    # Return the preprocessed image numpy array
    return img_array

def detect_contours(image):
    # Convert to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply adaptive thresholding
    thresh = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 11, 2)

    # Find contours
    contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter contours by size
    char_contours = [cnt for cnt in contours if cv2.contourArea(cnt) > 20]

    # Plot detected contours
    marked_image = image.copy()
    cv2.drawContours(marked_image, char_contours, -1, (0, 255, 0), 2)

    return marked_image, char_contours

def fit_line_and_plot(image, char_contours):
    # Get the bottom points of each contour
    bottom_points = []
    for cnt in char_contours:
        bottom = tuple(cnt[cnt[:,:,1].argmax()][0])
        bottom_points.append(bottom)

    # Sort points by x-coordinate
    bottom_points.sort(key=lambda p: p[0])

    # Fit a line to the bottom points
    vx, vy, x0, y0 = cv2.fitLine(np.array(bottom_points), cv2.DIST_L2, 0, 0.01, 0.01)

    # Calculate the endpoints of the line to draw
    (h, w) = image.shape[:2]
    x1 = int(((h-y0) * vx / vy) + x0)
    y1 = h - 1
    x2 = int((-y0 * vx / vy) + x0)
    y2 = 0

    # Plot the line on the image
    marked_image = image.copy()
    cv2.line(marked_image, (x1, y1), (x2, y2), (0, 0, 255), 2)  # Red line

    # Plot circles on bottom points
    for point in bottom_points:
        cv2.circle(marked_image, point, 5, (0, 255, 0), -1)  # Green circles

    return marked_image

def straighten_text(image):
    # Part 1: Detect contours and plot them
    marked_image, char_contours = detect_contours(image)

    # Part 2: Fit a line to bottom points and plot it
    marked_image_with_line = fit_line_and_plot(marked_image, char_contours)

    # Part 3: Rotate the image to straighten the text
    # Calculate the angle of the line
    vx, vy, _, _ = cv2.fitLine(np.array([cnt[cnt[:,:,1].argmax()][0] for cnt in char_contours]), cv2.DIST_L2, 0, 0.01, 0.01)
    angle = np.arctan2(vy[0], vx[0]) * 180 / np.pi

    # Rotate the image
    (h, w) = image.shape[:2]
    center = (w // 2, h // 2)
    M = cv2.getRotationMatrix2D(center, angle, 1.0)
    rotated = cv2.warpAffine(image, M, (w, h), flags=cv2.INTER_CUBIC, borderMode=cv2.BORDER_REPLICATE)

    return rotated, marked_image_with_line

image = cv2.imread('zom.png')

if image is None:
    print("Error: Unable to read the image. Please check the file path.")
else:
    straightened, marked_image = straighten_text(image)

    # Display results
    plt.figure(figsize=(16, 8))

    plt.subplot(131), plt.imshow(cv2.cvtColor(image, cv2.COLOR_BGR2RGB))
    plt.title('Original Image'), plt.axis('off')

    plt.subplot(132), plt.imshow(cv2.cvtColor(marked_image, cv2.COLOR_BGR2RGB))
    plt.title('Original with Marked Points and Fitted Line'), plt.axis('off')

    plt.subplot(133), plt.imshow(cv2.cvtColor(straightened, cv2.COLOR_BGR2RGB))
    plt.title('Straightened Text'), plt.axis('off')

    plt.tight_layout()
    plt.show()

"""**Testing using inbuilt libraries**"""

import cv2
import easyocr

def perform_ocr(image):
    # Initialize EasyOCR reader
    reader = easyocr.Reader(['en'])  # Specify language(s) for OCR

    # Perform OCR on the image
    result = reader.readtext(image)

    # Print the detected text and confidence scores
    print("Detected Text and Confidence Scores:")
    for detection in result:
        print(f"Text: {detection[1]}")
        # print(f"Text: {detection[1]}, Confidence: {detection[2]:.2f}")

    return result

# Load and straighten the image (assuming 'image' is already straightened)
image_path = 'coca.png'
image = cv2.imread(image_path)
# image = straightened

if image is None:
    print("Error: Unable to read the image. Please check the file path.")
else:
    # Perform OCR on the straightened image
    result = perform_ocr(image)

"""**Coming Up...**"""

import cv2
import numpy as np
from scipy.interpolate import UnivariateSpline
from google.colab.patches import cv2_imshow

def load_and_preprocess_image(file_path):
    # Load image
    image = cv2.imread(file_path)

    # Convert to grayscale
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply thresholding to get binary image
    _, binary = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY_INV)

    return image, binary

def find_and_filter_contours(binary_image, min_area=300):
    # Find contours
    contours, _ = cv2.findContours(binary_image, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

    # Filter contours based on area
    filtered_contours = [contour for contour in contours if cv2.contourArea(contour) > min_area]

    return filtered_contours

def draw_contours(image, contours):
    # Draw contours on image
    cv2.drawContours(image, contours, -1, (0, 255, 0), 2)

    return image

def calculate_centroids(contours):
    # Calculate centroids of contours
    centroids = [cv2.moments(contour) for contour in contours]
    centroids = [(int(M['m10'] / M['m00']), int(M['m01'] / M['m00'])) for M in centroids if M['m00'] != 0]

    return centroids

def smooth_and_draw_curve(image, centroids):
    # Extract x and y coordinates from centroids
    centroids_x, centroids_y = zip(*centroids)

    # Perform spline interpolation
    if len(centroids_x) > 1:
        spline = UnivariateSpline(centroids_x, centroids_y)
        x_smooth = np.linspace(min(centroids_x), max(centroids_x), 1000)
        y_smooth = spline(x_smooth)

        # Draw smoothed curve on image
        for i in range(len(x_smooth) - 1):
            cv2.line(image, (int(x_smooth[i]), int(y_smooth[i])),
                     (int(x_smooth[i + 1]), int(y_smooth[i + 1])), (255, 0, 0), 2)

    return image

def main():
    # Load and preprocess the image
    image, binary = load_and_preprocess_image('hey.png')

    # Find and filter contours
    contours = find_and_filter_contours(binary)

    # Draw contours on image
    image_with_contours = draw_contours(image.copy(), contours)

    # Calculate centroids
    centroids = calculate_centroids(contours)

    # Smooth and draw curve on image
    image_with_curve = smooth_and_draw_curve(image.copy(), centroids)

    # Display the results
    cv2_imshow(image_with_contours)
    cv2_imshow(image_with_curve)

if __name__ == "__main__":
    main()